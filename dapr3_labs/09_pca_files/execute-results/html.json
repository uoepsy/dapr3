{
  "hash": "6acaa2202688241de8d3f524a8c9d936",
  "result": {
    "markdown": "---\ntitle: \"Principal Component Analysis (PCA)\"\nlink-citations: yes\nparams: \n    SHOW_SOLS: TRUE\n    TOGGLE: TRUE\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n:::lo\n**Relevant packages**\n\n+ psych\n\n::: \n\n:::statbox\n**Thinking about measurement**  \n\nTake a moment to think about the various constructs that you are often interested in as a researcher. This might be anything from personality traits, to language proficiency, social identity, anxiety etc. \nHow we measure such constructs is a very important consideration for research. The things we're interested in are very rarely the things we are *directly* measuring. \n\nConsider how we might assess levels of anxiety or depression. Can we ever directly measure anxiety? ^[Even if we cut open someone's brain, it's unclear what we would be looking for in order to 'measure' it. It is unclear whether anxiety even exists as a physical thing, or rather if it is simply the overarching concept we apply to a set of behaviours and feelings]. More often than not, we measure these things using questionnaire based methods, to capture the multiple dimensions of the thing we are trying to assess. Twenty questions all measuring different aspects of anxiety are (we hope) going to correlate with one another if they are capturing some commonality (the construct of \"anxiety\"). But they introduce a problem for us, which is how to deal with 20 variables that represent (in broad terms) the same thing. How can we assess \"effects on anxiety\", rather than \"effects on anxiety q1\", \"effects on anxiety q2\", ..., etc.  \n\nThis leads us to the idea of *reducing the dimensionality of our data*. Can we capture a reasonable amount of the information from our 20 questions in a smaller number of variables? \n\n:::lo\n\nThe goal of principal component analysis (PCA) is to find a _smaller_ number of uncorrelated variables which are linear combinations of the original ( _many_ ) variables and explain most of the variation in the data.\n\n:::\n\n\n:::\n\n\n\n:::frame\n__Data: Job Performance__  \n\nThe file [job_performance.csv](https://uoepsy.github.io/data/job_performance.csv) (available at https://uoepsy.github.io/data/job_performance.csv) contains data on fifty police officers who were rated in six different categories as part of an HR procedure. The rated skills were:\n\n- communication skills: `commun`\n- problem solving: `probl_solv`\n- logical ability: `logical`\n- learning ability: `learn`\n- physical ability: `physical`\n- appearance: `appearance`\n\n:::\n\n\n\n<div class='question-begin'>Question A1</div><div class='question-body'>\n\n\nLoad the job performance data into R and call it `job`. \nCheck whether or not the data were read correctly into R - do the dimensions correspond to the description of the data above?\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-1' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-1', 'sol-start-1')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-1\" style=\"display: none;\">\n\n\nLet's load the data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\njob <- read_csv('https://uoepsy.github.io/data/job_performance.csv')\ndim(job)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50  6\n```\n:::\n:::\n\nThere are 50 observations on 6 variables.\n\nThe top 6 rows in the data are:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(job)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  commun probl_solv logical learn physical appearance\n   <dbl>      <dbl>   <dbl> <dbl>    <dbl>      <dbl>\n1     12         52      20    44       48         16\n2     12         57      25    45       50         16\n3     12         54      21    45       50         16\n4     13         52      21    46       51         17\n5     14         54      24    46       51         17\n6     14         48      20    47       51         18\n```\n:::\n:::\n\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n\n\n<div class='question-begin'>Question A2</div><div class='question-body'>\n\n\nProvide descriptive statistics for each variable in the dataset.\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-2' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-2', 'sol-start-2')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-2\" style=\"display: none;\">\n\n\nWe now inspect some descriptive statistics for each variable in the dataset:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Quick summary\nsummary(job)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     commun       probl_solv      logical       learn         physical   \n Min.   :12.0   Min.   :48.0   Min.   :20   Min.   :44.0   Min.   :48.0  \n 1st Qu.:16.0   1st Qu.:52.2   1st Qu.:22   1st Qu.:48.0   1st Qu.:52.2  \n Median :18.0   Median :54.0   Median :24   Median :50.0   Median :54.0  \n Mean   :17.7   Mean   :54.2   Mean   :24   Mean   :50.3   Mean   :54.2  \n 3rd Qu.:19.8   3rd Qu.:56.0   3rd Qu.:26   3rd Qu.:52.0   3rd Qu.:56.0  \n Max.   :24.0   Max.   :59.0   Max.   :31   Max.   :56.0   Max.   :59.0  \n   appearance  \n Min.   :16.0  \n 1st Qu.:19.0  \n Median :21.0  \n Mean   :21.1  \n 3rd Qu.:23.0  \n Max.   :28.0  \n```\n:::\n:::\n\n\n__OPTIONAL__\n\nIf you wish to create a nice looking table for a report, you could try the following code. \nHowever, I should warn you: this code is quite difficult to understand so, if you are interested, attend a lab!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(gt)\n\n# Mean and SD of each variable\njob %>% \n  summarise(across(everything(), list(M = mean, SD = sd))) %>%\n  pivot_longer(everything()) %>% \n  mutate(\n    value = round(value, 2),\n    name = str_replace(name, '_M', '.M'),\n    name = str_replace(name, '_SD', '.SD')\n  ) %>%\n  separate(name, into = c('variable', 'summary'), sep = '\\\\.') %>%\n  pivot_wider(names_from = summary, values_from = value) %>% \n  gt()\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"uwhmwbzdri\" style=\"overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>html {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#uwhmwbzdri .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#uwhmwbzdri .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#uwhmwbzdri .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#uwhmwbzdri .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#uwhmwbzdri .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#uwhmwbzdri .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#uwhmwbzdri .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#uwhmwbzdri .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#uwhmwbzdri .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#uwhmwbzdri .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#uwhmwbzdri .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#uwhmwbzdri .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#uwhmwbzdri .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwhmwbzdri .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#uwhmwbzdri .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#uwhmwbzdri .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwhmwbzdri .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#uwhmwbzdri .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwhmwbzdri .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#uwhmwbzdri .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwhmwbzdri .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#uwhmwbzdri .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwhmwbzdri .gt_left {\n  text-align: left;\n}\n\n#uwhmwbzdri .gt_center {\n  text-align: center;\n}\n\n#uwhmwbzdri .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#uwhmwbzdri .gt_font_normal {\n  font-weight: normal;\n}\n\n#uwhmwbzdri .gt_font_bold {\n  font-weight: bold;\n}\n\n#uwhmwbzdri .gt_font_italic {\n  font-style: italic;\n}\n\n#uwhmwbzdri .gt_super {\n  font-size: 65%;\n}\n\n#uwhmwbzdri .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 75%;\n  vertical-align: 0.4em;\n}\n\n#uwhmwbzdri .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#uwhmwbzdri .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#uwhmwbzdri .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#uwhmwbzdri .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#uwhmwbzdri .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#uwhmwbzdri .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\">\n  \n  <thead class=\"gt_col_headings\">\n    <tr>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\">variable</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\">M</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\">SD</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td class=\"gt_row gt_left\">commun</td>\n<td class=\"gt_row gt_right\">17.7</td>\n<td class=\"gt_row gt_right\">2.74</td></tr>\n    <tr><td class=\"gt_row gt_left\">probl_solv</td>\n<td class=\"gt_row gt_right\">54.2</td>\n<td class=\"gt_row gt_right\">2.41</td></tr>\n    <tr><td class=\"gt_row gt_left\">logical</td>\n<td class=\"gt_row gt_right\">24.0</td>\n<td class=\"gt_row gt_right\">2.49</td></tr>\n    <tr><td class=\"gt_row gt_left\">learn</td>\n<td class=\"gt_row gt_right\">50.3</td>\n<td class=\"gt_row gt_right\">2.84</td></tr>\n    <tr><td class=\"gt_row gt_left\">physical</td>\n<td class=\"gt_row gt_right\">54.2</td>\n<td class=\"gt_row gt_right\">2.41</td></tr>\n    <tr><td class=\"gt_row gt_left\">appearance</td>\n<td class=\"gt_row gt_right\">21.1</td>\n<td class=\"gt_row gt_right\">2.99</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n:::\n:::\n\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n# Preliminaries \n## Is PCA needed?\n\n:::lo \n\nIf the original variables are highly correlated, it is possible to reduce the dimensionality of the problem under investigation without losing too much information.\n\nOn the other side, when the correlation between the variables under study is weak, a larger number of components is needed in order to explain sufficient variability.\n\n:::\n\n\n\n<div class='question-begin'>Question A3</div><div class='question-body'>\n\n\nInvestigate whether or not the recorded variables are highly correlated and explain whether or not you PCA might be useful in this case.  \n\n**Hint:** We only have 6 variables here, but if we had many, how might you visualise `cor(job)`?\n\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-3' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-3', 'sol-start-3')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-3\" style=\"display: none;\">\n\n\nLet's start by looking at the correlation matrix of the data:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(pheatmap)\n\nR <- cor(job)\n\npheatmap(R, breaks = seq(-1, 1, length.out = 100))\n```\n\n::: {.cell-output-display}\n![Correlation between the variables in the ``Job'' dataset](09_pca_files/figure-html/fig-jobcor-1.png){#fig-jobcor fig-align='center' width=80%}\n:::\n:::\n\n\nThe correlation between the variables seems to be quite large (it doesn't matter about direction here, only magnitude; if negative correlations were present, we would think in absolute value).\n\nThere appears to be a group of highly correlated variables comprising physical ability, appearance, communication skills, and learning ability which are correlated among themselves but uncorrelated with another group of variables.\nThe second group comprises problem solving and logical ability.\n\nThis suggests that PCA might be useful in this problem to reduce the dimensionality without a significant loss of information.\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n## Cov vs Cor\n\n:::statbox\n**Should we perform PCA on the covariance or the correlation matrix?**  \n  \nThis depends on the variances of the variables in the dataset.\nIf the variables have large differences in their variances, then the variables with the largest variances will tend to dominate the first few principal components.  \n\nA solution to this is to standardise the variables prior to computing the covariance matrix - i.e., compute the correlation matrix!  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# show that the correlation matrix and the covariance matrix of the standardized variables are identical\nall.equal(cor(job), cov(scale(job)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n\n\n<div class='question-begin'>Question A4</div><div class='question-body'>\n\n\nLook at the variance of the variables in the data set. Do you think that PCA should be carried on the covariance matrix or the correlation matrix?\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-4' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-4', 'sol-start-4')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-4\" style=\"display: none;\">\n\n\nLet's have a look at the standard deviation of each variable:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob %>% \n  summarise(across(everything(), sd))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  commun probl_solv logical learn physical appearance\n   <dbl>      <dbl>   <dbl> <dbl>    <dbl>      <dbl>\n1   2.74       2.41    2.49  2.84     2.41       2.99\n```\n:::\n:::\n\n\nAs the standard deviations appear to be fairly similar (and so will the variances) we can perform PCA using the covariance matrix.\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n\n\n# Perform PCA\n\n\n\n<div class='question-begin'>Question A5</div><div class='question-body'>\n\n\nUsing the `principal()` function from the `psych` package, we can perform a PCA of the job performance data, Call the output `job_pca`.\n```\njob_pca <- principal(job, nfactors = ncol(job), covar = ..., rotate = 'none')\njob_pca$loadings\n```\nDepending on your answer to the previous question, either set `covar = TRUE` or `covar = FALSE` within the `principal()` function.\n\n**Warning:** the output of the function will be in terms of standardized variables nevertheless. So you will see output with standard deviation of 1.  \n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-5' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-5', 'sol-start-5')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-5\" style=\"display: none;\">\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(psych)\n\njob_pca <- principal(job, nfactors = ncol(job), covar = TRUE, rotate = 'none')\n```\n:::\n\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n## The output  \n\n:::frame\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob_pca$loadings\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nLoadings:\n           PC1    PC2    PC3    PC4    PC5    PC6   \ncommun      0.984 -0.120                0.101       \nprobl_solv  0.223  0.810  0.543                     \nlogical     0.329  0.747 -0.578                     \nlearn       0.987 -0.110                       0.105\nphysical    0.988                      -0.110       \nappearance  0.979 -0.125         0.161              \n\n                 PC1   PC2   PC3   PC4   PC5   PC6\nSS loadings    4.035 1.261 0.631 0.035 0.022 0.016\nProportion Var 0.673 0.210 0.105 0.006 0.004 0.003\nCumulative Var 0.673 0.883 0.988 0.994 0.997 1.000\n```\n:::\n:::\n\nThe output is made up of two parts.\n\nFirst, it shows the *loading matrix*. In each column of the loading matrix we find how much each of the measured variables contributes to the computed new axis/direction (that is, the principal component).\nNotice that there are as many principal components as variables. \n\nThe second part of the output displays the contribution of each component to the total variance.\n\nBefore interpreting it however, let's focus on the last row of that output called \"Cumulative Var\". This displays the cumulative sum of the variances of each principal component.\nTaken all together, the six principal components taken explain all of the total variance in the original data.\nIn other words, the total variance of the principal components (the sum of their variances) is equal to the total variance in the original data (the sum of the variances of the variables).\n\nHowever, our goal is to reduce the dimensionality of our data, so it comes natural to wonder which of the six principal components explain most of the variability, and which components instead do not contribute substantially to the total variance.\n\nTo that end, the second row \"Proportion Var\" displays the proportion of the total variance explained by each component, i.e. the variance of the principal component divided by the total variance.\n\nThe last row, as we saw, is the cumulative proportion of explained variance: `0.673`, `0.673 + 0.210`, `0.673 + 0.210 + 0.105`, and so on.\n\nWe also notice that the first PC alone explains 67.3% of the total variability, while the first two components together explain almost 90% of the total variability.\nFrom the third component onwards, we do not see such a sharp increase in the proportion of explained variance, and the cumulative proportion slowly reaches the total ratio of 1 (or 100%).\n\n:::\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-6' class=\"fa fa-hand-o-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-6', 'opt-start-6')\"> <span class=\"olab\">Optional: (some of) the math behind it</span></span></div><div class=\"optional-body\" id = \"opt-body-6\" style=\"display: none;\">\n\n\n\nDoing data reduction can feel a bit like magic, and in part that's just because it's quite complicated. \n\n**The intuition**  \n\nConsider one way we might construct a correlation matrix - as the product of vector $\\mathbf{f}$ with $\\mathbf{f'}$ (f transposed): \n\n$$\n\\begin{equation*}\n\\mathbf{f} = \n\\begin{bmatrix}\n0.9 \\\\\n0.8 \\\\\n0.7 \\\\\n0.6 \\\\\n0.5 \\\\\n0.4 \\\\\n\\end{bmatrix} \n\\qquad \n\\mathbf{f} \\mathbf{f'} = \n\\begin{bmatrix}\n0.9 \\\\\n0.8 \\\\\n0.7 \\\\\n0.6 \\\\\n0.5 \\\\\n0.4 \\\\\n\\end{bmatrix} \n\\begin{bmatrix}\n0.9, 0.8, 0.7, 0.6, 0.5, 0.4 \\\\\n\\end{bmatrix} \n\\qquad = \\qquad\n\\begin{bmatrix}\n0.81, 0.72, 0.63, 0.54, 0.45, 0.36 \\\\\n0.72, 0.64, 0.56, 0.48, 0.40, 0.32 \\\\\n0.63, 0.56, 0.49, 0.42, 0.35, 0.28 \\\\\n0.54, 0.48, 0.42, 0.36, 0.30, 0.24 \\\\\n0.45, 0.40, 0.35, 0.30, 0.25, 0.20 \\\\\n0.36, 0.32, 0.28, 0.24, 0.20, 0.16 \\\\\n\\end{bmatrix} \n\\end{equation*} \n$$\n\n\nBut we constrain this such that the diagonal has values of 1 (the correlation of a variable with itself is 1), and lets call it **R**.\n\n$$\n\\begin{equation*}\n\\mathbf{R} = \n\\begin{bmatrix}\n1.00, 0.72, 0.63, 0.54, 0.45, 0.36 \\\\\n0.72, 1.00, 0.56, 0.48, 0.40, 0.32 \\\\\n0.63, 0.56, 1.00, 0.42, 0.35, 0.28 \\\\\n0.54, 0.48, 0.42, 1.00, 0.30, 0.24 \\\\\n0.45, 0.40, 0.35, 0.30, 1.00, 0.20 \\\\\n0.36, 0.32, 0.28, 0.24, 0.20, 1.00 \\\\\n\\end{bmatrix} \n\\end{equation*} \n$$\n\n\nPCA is about trying to determine a vector **f** which generates the correlation matrix **R**. a bit like unscrambling eggs!  \n\nin PCA, we express $\\mathbf{R = CC'}$, where $\\mathbf{C}$ are our principal components.  \nIf $n$ is number of variables in $R$, then $i^{th}$ component $C_i$ is the linear sum of each variable multiplied by some weighting:  \n\n$$\nC_i = \\sum_{j=1}^{n}w_{ij}x_{j}\n$$\n\n\n**How do we find $C$?**\n\nThis is where \"eigen decomposition\" comes in.  \nFor the $n \\times n$ correlation matrix $\\mathbf{R}$, there is an **eigenvector** $x_i$ that solves the equation \n\n$$\n\\mathbf{x_i R} = \\lambda_i \\mathbf{x_i}\n$$\n\nWhere the vector multiplied by the correlation matrix is equal to some **eigenvalue** $\\lambda_i$ multiplied by that vector.  \nWe can write this without subscript $i$ as: \n\n$$\n\\begin{align}\n& \\mathbf{R X} = \\mathbf{X \\lambda} \\\\\n& \\text{where:} \\\\\n& \\mathbf{R} = \\text{correlation matrix} \\\\\n& \\mathbf{X} = \\text{matrix of eigenvectors} \\\\\n& \\mathbf{\\lambda} = \\text{vector of eigenvalues}\n\\end{align}\n$$\n\nthe vectors which make up $\\mathbf{X}$ must be orthogonal [($\\mathbf{XX' = I}$)](https://miro.medium.com/max/700/1*kyg5XbrY1AOB946IE5nWWg.png), which means that $\\mathbf{R = X \\lambda X'}$\n \nWe can actually do this in R manually. \nCreating a correlation matrix\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# lets create a correlation matrix, as the produce of ff'\nf <- seq(.9,.4,-.1)\nR <- f %*% t(f)\n#give rownames and colnames\nrownames(R)<-colnames(R)<-paste0(\"V\",seq(1:6))\n#constrain diagonals to equal 1\ndiag(R)<-1\nR\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     V1   V2   V3   V4   V5   V6\nV1 1.00 0.72 0.63 0.54 0.45 0.36\nV2 0.72 1.00 0.56 0.48 0.40 0.32\nV3 0.63 0.56 1.00 0.42 0.35 0.28\nV4 0.54 0.48 0.42 1.00 0.30 0.24\nV5 0.45 0.40 0.35 0.30 1.00 0.20\nV6 0.36 0.32 0.28 0.24 0.20 1.00\n```\n:::\n:::\n\n\nEigen Decomposition\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# do eigen decomposition\ne <- eigen(R)\nprint(e, digits=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neigen() decomposition\n$values\n[1] 3.16 0.82 0.72 0.59 0.44 0.26\n\n$vectors\n      [,1]   [,2]   [,3]  [,4]   [,5]   [,6]\n[1,] -0.50 -0.061  0.092  0.14  0.238  0.816\n[2,] -0.47 -0.074  0.121  0.21  0.657 -0.533\n[3,] -0.43 -0.096  0.182  0.53 -0.675 -0.184\n[4,] -0.39 -0.142  0.414 -0.78 -0.201 -0.104\n[5,] -0.34 -0.299 -0.860 -0.20 -0.108 -0.067\n[6,] -0.28  0.934 -0.178 -0.10 -0.067 -0.045\n```\n:::\n:::\n\n\nThe eigenvectors are orthogonal ($\\mathbf{XX' = I}$):\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nround(e$vectors %*% t(e$vectors),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    0    0    0    0    0\n[2,]    0    1    0    0    0    0\n[3,]    0    0    1    0    0    0\n[4,]    0    0    0    1    0    0\n[5,]    0    0    0    0    1    0\n[6,]    0    0    0    0    0    1\n```\n:::\n:::\n\n\nThe Principal Components $\\mathbf{C}$ are the eigenvectors scaled by the square root of the eigenvalues:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#eigenvectors\ne$vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]    [,2]    [,3]   [,4]    [,5]    [,6]\n[1,] -0.496 -0.0611  0.0923  0.139  0.2385  0.8155\n[2,] -0.468 -0.0743  0.1210  0.214  0.6566 -0.5327\n[3,] -0.433 -0.0963  0.1820  0.530 -0.6751 -0.1842\n[4,] -0.390 -0.1416  0.4143 -0.778 -0.2006 -0.1036\n[5,] -0.340 -0.2992 -0.8604 -0.197 -0.1076 -0.0669\n[6,] -0.282  0.9338 -0.1784 -0.100 -0.0667 -0.0452\n```\n:::\n\n```{.r .cell-code}\n#scaled by sqrt of eigenvalues\ndiag(sqrt(e$values))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n[1,] 1.78 0.000 0.000 0.000 0.000 0.000\n[2,] 0.00 0.906 0.000 0.000 0.000 0.000\n[3,] 0.00 0.000 0.848 0.000 0.000 0.000\n[4,] 0.00 0.000 0.000 0.769 0.000 0.000\n[5,] 0.00 0.000 0.000 0.000 0.664 0.000\n[6,] 0.00 0.000 0.000 0.000 0.000 0.512\n```\n:::\n\n```{.r .cell-code}\nC <- e$vectors %*% diag(sqrt(e$values))\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]    [,2]    [,3]    [,4]    [,5]    [,6]\n[1,] -0.883 -0.0554  0.0782  0.1070  0.1584  0.4174\n[2,] -0.833 -0.0673  0.1025  0.1648  0.4361 -0.2727\n[3,] -0.770 -0.0873  0.1542  0.4077 -0.4483 -0.0943\n[4,] -0.694 -0.1284  0.3512 -0.5987 -0.1332 -0.0530\n[5,] -0.604 -0.2712 -0.7293 -0.1514 -0.0715 -0.0342\n[6,] -0.502  0.8464 -0.1513 -0.0771 -0.0443 -0.0231\n```\n:::\n:::\n\n\nAnd we can reproduce our correlation matrix, because $\\mathbf{R = CC'}$. \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nC %*% t(C)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,] 1.00 0.72 0.63 0.54 0.45 0.36\n[2,] 0.72 1.00 0.56 0.48 0.40 0.32\n[3,] 0.63 0.56 1.00 0.42 0.35 0.28\n[4,] 0.54 0.48 0.42 1.00 0.30 0.24\n[5,] 0.45 0.40 0.35 0.30 1.00 0.20\n[6,] 0.36 0.32 0.28 0.24 0.20 1.00\n```\n:::\n:::\n\nNow lets imagine we only consider 1 principal component.  \nWe can do this with the `principal()` function: \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(psych)\npc1<-principal(R, nfactors = 1, covar = FALSE, rotate = 'none')\npc1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrincipal Components Analysis\nCall: principal(r = R, nfactors = 1, rotate = \"none\", covar = FALSE)\nStandardized loadings (pattern matrix) based upon correlation matrix\n    PC1   h2   u2 com\nV1 0.88 0.78 0.22   1\nV2 0.83 0.69 0.31   1\nV3 0.77 0.59 0.41   1\nV4 0.69 0.48 0.52   1\nV5 0.60 0.37 0.63   1\nV6 0.50 0.25 0.75   1\n\n                PC1\nSS loadings    3.16\nProportion Var 0.53\n\nMean item complexity =  1\nTest of the hypothesis that 1 component is sufficient.\n\nThe root mean square of the residuals (RMSR) is  0.09 \n\nFit based upon off diagonal values = 0.95\n```\n:::\n:::\n\n\nLook familiar? It looks like the first component we computed manually. The first column of $\\mathbf{C}$:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncbind(pc1$loadings, C=C[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     PC1      C\nV1 0.883 -0.883\nV2 0.833 -0.833\nV3 0.770 -0.770\nV4 0.694 -0.694\nV5 0.604 -0.604\nV6 0.502 -0.502\n```\n:::\n:::\n\nWe can now ask \"how well does this component (on its own) recreate our correlation matrix?\" \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nC[,1] %*% t(C[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n[1,] 0.780 0.735 0.680 0.613 0.534 0.444\n[2,] 0.735 0.693 0.641 0.578 0.503 0.418\n[3,] 0.680 0.641 0.592 0.534 0.465 0.387\n[4,] 0.613 0.578 0.534 0.481 0.419 0.348\n[5,] 0.534 0.503 0.465 0.419 0.365 0.304\n[6,] 0.444 0.418 0.387 0.348 0.304 0.252\n```\n:::\n:::\n\nIt looks close, but not quite. How much not quite? Measurably so!\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nR - (C[,1] %*% t(C[,1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        V1      V2      V3      V4      V5      V6\nV1  0.2200 -0.0154 -0.0498 -0.0727 -0.0838 -0.0836\nV2 -0.0154  0.3067 -0.0809 -0.0976 -0.1033 -0.0982\nV3 -0.0498 -0.0809  0.4075 -0.1140 -0.1153 -0.1066\nV4 -0.0727 -0.0976 -0.1140  0.5187 -0.1193 -0.1085\nV5 -0.0838 -0.1033 -0.1153 -0.1193  0.6346 -0.1036\nV6 -0.0836 -0.0982 -0.1066 -0.1085 -0.1036  0.7477\n```\n:::\n:::\n\n\nNotice the values on the diagonals?\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndiag(C[,1] %*% t(C[,1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.780 0.693 0.592 0.481 0.365 0.252\n```\n:::\n\n```{.r .cell-code}\ndiag(R) - diag(C[,1] %*% t(C[,1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   V1    V2    V3    V4    V5    V6 \n0.220 0.307 0.408 0.519 0.635 0.748 \n```\n:::\n\n```{.r .cell-code}\npc1$communality\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   V1    V2    V3    V4    V5    V6 \n0.780 0.693 0.592 0.481 0.365 0.252 \n```\n:::\n\n```{.r .cell-code}\npc1$uniquenesses\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   V1    V2    V3    V4    V5    V6 \n0.220 0.307 0.408 0.519 0.635 0.748 \n```\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## How many components to keep?\n\n:::lo\n\nThere is no single best method to select the optimal number of components to keep, while discarding the remaining ones (which are then considered as noise components).\n\nThe following three heuristic rules are commonly used in the literature:\n\n- The cumulative proportion of explained variance criterion\n- Kaiser's rule\n- The scree plot\n- Velicer's Minimum Average Partial method\n- Parallel analysis\n\nIn the next sections we will analyse each of them in turn.\n\n:::\n\n:::statbox\n**The cumulative proportion of explained variance criterion**\n\nThe rule suggests to *keep as many principal components as needed in order to explain approximately 80-90% of the total variance.*\n\n:::\n\n\n\n<div class='question-begin'>Question A6</div><div class='question-body'>\n\n\nLooking again at the PCA output, how many principal components would you keep if you were following the cumulative proportion of explained variance criterion?\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-7' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-7', 'sol-start-7')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-7\" style=\"display: none;\">\n\n\nLet's look again at the PCA summary:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob_pca$loadings\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nLoadings:\n           PC1    PC2    PC3    PC4    PC5    PC6   \ncommun      0.984 -0.120                0.101       \nprobl_solv  0.223  0.810  0.543                     \nlogical     0.329  0.747 -0.578                     \nlearn       0.987 -0.110                       0.105\nphysical    0.988                      -0.110       \nappearance  0.979 -0.125         0.161              \n\n                 PC1   PC2   PC3   PC4   PC5   PC6\nSS loadings    4.035 1.261 0.631 0.035 0.022 0.016\nProportion Var 0.673 0.210 0.105 0.006 0.004 0.003\nCumulative Var 0.673 0.883 0.988 0.994 0.997 1.000\n```\n:::\n:::\n\n\nThe following part of the output tells us that the first two components explain 88.3% of the total variance.\n```\nCumulative Var 0.673 0.883 0.988 0.994 0.997 1.000\n```\n\nAccording to this criterion, we should keep 2 principal components.\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n:::statbox\n**Kaiser's rule**  \n  \nAccording to Kaiser's rule, we should **keep the principal components having variance larger than 1**. Standardized variables have a variance equal 1. Because we have 6 variables in the data set, and the total variance is 6, the value 1 represents the average variance in the data:\n\n$$\n\\frac{1 + 1 + 1 + 1 + 1 + 1}{6} = 1\n$$\n\n\n__Hint:__\n\nThe variances of each PC are shown in the row of the output named `SS loadings` and also in\n`job_pca$values`. The average variance is:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(job_pca$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n:::\n\n\n\n<div class='question-begin'>Question A7</div><div class='question-body'>\n\n\nLooking again at the PCA output, how many principal components would you keep if you were following Kaiser's criterion?\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-8' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-8', 'sol-start-8')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-8\" style=\"display: none;\">\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob_pca$loadings\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nLoadings:\n           PC1    PC2    PC3    PC4    PC5    PC6   \ncommun      0.984 -0.120                0.101       \nprobl_solv  0.223  0.810  0.543                     \nlogical     0.329  0.747 -0.578                     \nlearn       0.987 -0.110                       0.105\nphysical    0.988                      -0.110       \nappearance  0.979 -0.125         0.161              \n\n                 PC1   PC2   PC3   PC4   PC5   PC6\nSS loadings    4.035 1.261 0.631 0.035 0.022 0.016\nProportion Var 0.673 0.210 0.105 0.006 0.004 0.003\nCumulative Var 0.673 0.883 0.988 0.994 0.997 1.000\n```\n:::\n:::\n\n\nThe variances are shown in the row\n```\nSS loadings    4.035 1.261 0.631 0.035 0.022 0.016\n```\n\nFrom the result we see that only the first two principal components have variance greater than 1, so this rule suggests to keep 2 PCs only.\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n:::statbox\n**The scree plot**\n\nThe scree plot is a graphical criterion which involves plotting the variance for each principal component.\nThis can be easily done by calling `plot` on the variances, which are stored in `job_pca$values`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(x = 1:length(job_pca$values), y = job_pca$values, \n     type = 'b', xlab = '', ylab = 'Variance', \n     main = 'Police officers: scree plot', frame.plot = FALSE)\n```\n\n::: {.cell-output-display}\n![](09_pca_files/figure-html/unnamed-chunk-24-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nwhere the argument `type = 'b'` tells R that the plot should have _both_ points and lines.\n\nA typical scree plot features higher variances for the initial components and quickly drops to small variances where the curve is almost flat.\nThe flat part of the curve represents the noise components, which are not able to capture the main sources of variability in the system. \n\nAccording to the scree plot criterion, we should **keep as many principal components as where the \"elbow\" in the plot occurs.** By elbow we mean the variance before the curve looks almost flat.\n\nAlternatively, some people prefer to use the function `scree()` from the `psych` package:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscree(job, factors = FALSE)\n```\n\n::: {.cell-output-display}\n![](09_pca_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nThis also draws a horizontal line at y = 1. So, if you are making a decision about how many PCs to keep by looking at where the plot falls below the y = 1 line, you are basically following Kaiser's rule. In fact, Kaiser's criterion tells you to keep as many PCs as are those with a variance (= eigenvalue) greater than 1.\n\n:::\n\n\n\n<div class='question-begin'>Question A8</div><div class='question-body'>\n\n\nAccording to the scree plot, how many principal components would you retain?\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-9' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-9', 'sol-start-9')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-9\" style=\"display: none;\">\n\n\nThis criterion then suggests to keep three principal components.\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n:::statbox\n**Velicer’s Minimum Average Partial method**\n\nThe Minimum Average Partial (MAP) test computes the partial correlation matrix (removing and adjusting for a component from the correlation matrix), sequentially partialling out each component. At each step, the partial correlations are squared and their average is computed.  \nAt first, the components which are removed will be those that are most representative of the shared variance between 2+ variables, meaning that the \"average squared partial correlation\" will decrease. At some point in the process, the components being removed will begin represent variance that is specific to individual variables, meaning that the average squared partial correlation will increase.  \nThe MAP method is to keep the number of components for which the average squared partial correlation is at the minimum. \n\nWe can conduct MAP in R using:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nVSS(data, plot = FALSE, method=\"pc\", n = ncol(data))\n```\n:::\n\n(be aware there is a lot of other information in this output too! For now just focus on the map column)\n\n:::\n\n\n\n<div class='question-begin'>Question A9</div><div class='question-body'>\n\n\nHow many components should we keep according to the MAP method?\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-10' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-10', 'sol-start-10')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-10\" style=\"display: none;\">\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob_map <- VSS(job, plot=FALSE, method=\"pc\", n = ncol(job))$map\npaste(\"MAP is lowest for\", which.min(job_map), \"components\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"MAP is lowest for 2 components\"\n```\n:::\n:::\n\n\nAccording to the MAP criterion we should keep 2 principal components.\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n\n:::statbox\n**Parallel analysis**\n\nParallel analysis involves simulating lots of datasets of the same dimension but in which the variables are uncorrelated. For each of these simulations, a PCA is conducted on its correlation matrix, and the eigenvalues are extracted. We can then compare our eigenvalues from the PCA on our *actual* data to the average eigenvalues across these simulations. \nIn theory, for uncorrelated variables, no components should explain more variance than any others, and eigenvalues should be equal to 1. In reality, variables are rarely truly uncorrelated, and so there will be slight variation in the magnitude of eigenvalues simply due to chance. \nThe parallel analysis method suggests keeping those components for which the eigenvalues are greater than those from the simulations. \n\nIt can be conducted in R using:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfa.parallel(job, fa=\"pc\", quant=.95)\n```\n:::\n\n\n:::\n\n\n\n\n<div class='question-begin'>Question A10</div><div class='question-body'>\n\n\nHow many components should we keep according to parallel analysis?\n\n\n</div><p class=\"question-end\"></p>\n\n\n\n\n<div class=\"solution-begin\"><span id='sol-start-11' class=\"fa fa-hand-o-right solution-icon clickable\" onclick=\"toggle_visibility('sol-body-11', 'sol-start-11')\">  Solution </span></div><div class=\"solution-body\" id = \"sol-body-11\" style=\"display: none;\">\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfa.parallel(job, fa=\"pc\", quant=.95)\n```\n\n::: {.cell-output-display}\n![](09_pca_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=80%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nParallel analysis suggests that the number of factors =  NA  and the number of components =  1 \n```\n:::\n:::\n\n\nParallel analysis suggests to keep 1 principal component only as there is only one PC with an eigenvalue higher than the simulated random ones in red.\n\n\n\n</div><p class=\"solution-end\"></p>\n\n\n\n\n# Interpretation\n\n:::frame\n\nBecause three out of the five selection criteria introduced above suggest to keep 2 principal components, in the following we will work with the first two PCs only.\n\nLet's have a look at the selected principal components:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob_pca$loadings[, 1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             PC1     PC2\ncommun     0.984 -0.1197\nprobl_solv 0.223  0.8095\nlogical    0.329  0.7466\nlearn      0.987 -0.1097\nphysical   0.988 -0.0784\nappearance 0.979 -0.1253\n```\n:::\n:::\n\n\nand at their corresponding proportion of total variance explained:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob_pca$values / sum(job_pca$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.67253 0.21016 0.10510 0.00577 0.00372 0.00273\n```\n:::\n:::\n\n\nWe see that the first PC accounts for 67.3% of the total variability. All loadings seem to have the same magnitude apart from `probl_solv` and `logical` which are closer to zero.\nThe first component looks like a sort of average of the officers performance scores excluding problem solving and logical ability.\n\nThe second principal component, which explains only 21% of the total variance, has two loadings clearly distant from zero: the ones associated to problem solving and logical ability.\nIt distinguishes police officers with strong logical and problem solving skills and a low score on the test (note the negative magnitude) from the other officers.\n\nWe have just seen how to interpret the first components by looking at the magnitude and sign of the coefficients for each measured variable.\n\n:::rtip\nFor interpretation purposes, it might help hiding very small loadings. This can be done by specifying the cutoff value in the `print()` function. However, this only works when you pass the loadings for **all** the PCs:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint(job_pca$loadings, cutoff = 0.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nLoadings:\n           PC1    PC2    PC3    PC4    PC5    PC6   \ncommun      0.984                                   \nprobl_solv         0.810  0.543                     \nlogical     0.329  0.747 -0.578                     \nlearn       0.987                                   \nphysical    0.988                                   \nappearance  0.979                                   \n\n                 PC1   PC2   PC3   PC4   PC5   PC6\nSS loadings    4.035 1.261 0.631 0.035 0.022 0.016\nProportion Var 0.673 0.210 0.105 0.006 0.004 0.003\nCumulative Var 0.673 0.883 0.988 0.994 0.997 1.000\n```\n:::\n:::\n\n\n:::\n<br>\n\n\n<div class=\"optional-begin\"><span id='opt-start-12' class=\"fa fa-hand-o-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-12', 'opt-start-12')\"> <span class=\"olab\">Optional: How well are the units represented in the reduced space?</span></span></div><div class=\"optional-body\" id = \"opt-body-12\" style=\"display: none;\">\n\n\n\nWe now focus our attention on the following question: Are all the statistical units (police officers) well represented in the 2D plot?\n\nThe 2D representation of the original data, which comprise 6 measured variables, is an approximation and henceforth it may happen that not all units are well represented in this new space.\n\nTypically, it is good to assess the approximation for each statistical unit by inspecting the scores on the discarded principal components.\nIf a unit has a high score on those components, then this is a sign that the unit might be highly misplaced in the new space and misrepresented.\n\nConsider the 3D example below. There are three cases (= units or individuals). In the original space they are all very different from each other. For example, cases 1 and 2 are very different in their x and y values, but very similar in their z value. Cases 2 and 3 are very similar in their x and y values but very different in their z value. Cases 1 and 3 have very different values for all three variables x, y, and z.\n\nHowever, when represented in the 2D space given by the two principal components, units 2 and 3 seems like they are very similar when, in fact, they were very different in the original space which also accounted for the z variable.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/pcaefa/pca_bad_representation.png){fig-align='center' width=\\textwidth}\n:::\n:::\n\n\nWe typically measure how badly a unit is represented in the new coordinate system by considering the **sum of squared scores on the discarded principal components:**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscores_discarded <- job_pca$scores[, -(1:2)]\nsum_sq <- rowSums(scores_discarded^2)\nsum_sq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  28.51  46.89  63.69  64.24  36.58  17.39  49.24  35.10  18.56  19.27\n[11]  18.56  24.44  12.39  59.10  24.43  33.18  13.40  12.69  11.22  78.87\n[21]  14.16  34.18  95.57  18.40  16.45  14.41  31.97  33.52  40.12  32.48\n[31]  16.85  24.85  30.84  16.00  29.59  11.01   8.07  18.18  14.60  23.73\n[41]  29.82  41.37   9.30  65.42  21.98  63.97  36.09  84.98 129.65  88.00\n```\n:::\n:::\n\n\nUnits with a high score should be considered for further inspection as it may happen that they are represented as close to another unit when, in fact, they might be very different.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nboxplot(sum_sq)\n```\n\n::: {.cell-output-display}\n![](09_pca_files/figure-html/unnamed-chunk-35-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nThere seem to be only five outliers, and they are not too high compared to the rest of the scores. For this reason, we will consider the 2D representation of the data to be satisfactory.\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n\n:::\n\n\n# PCA scores\n\nSupposing that we decide to reduce our six variables down to two principal components:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njob_pca2 <- principal(job, nfactors = 2, covar = TRUE, rotate = 'none')\n```\n:::\n\n\n\n:::rtip\nWe can, for each of our observations, get their _scores_ on each of our components.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(job_pca2$scores)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       PC1    PC2\n[1,] -6.10 -1.796\n[2,] -4.69  4.164\n[3,] -5.18 -0.131\n[4,] -4.31 -1.758\n[5,] -3.71  1.207\n[6,] -3.88 -5.200\n```\n:::\n:::\n\n:::\n\nIn the literature, some authors also suggest to look at the correlation between each principal component and the measured variables:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# First PC\ncor(job_pca2$scores[,1], job)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     commun probl_solv logical learn physical appearance\n[1,]  0.985      0.214   0.319 0.988    0.989      0.981\n```\n:::\n:::\n\n\nThe first PC is strongly correlated with all the measured variables except `probl_solv` and `logical`.\nAs we mentioned above, all variables seem to contributed to the first PC.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Second PC\ncor(job_pca2$scores[,2], job)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     commun probl_solv logical  learn physical appearance\n[1,] -0.163      0.792   0.738 -0.154   -0.122     -0.169\n```\n:::\n:::\n\n\nThe second PC is strongly correlated with `probl_solv` and `logical`, and slightly negatively correlated with the remaining variables. This separates police offices with clear logical and problem solving skills and a small score on the test (negative sign) from the others.\n\n:::lo\nWe have reduced our six variables down to two principal components, and we are now able to use the scores on each component in a subsequent analysis! \n\nFor instance, __if__ we also had information on how many arrests each police officer made, and the HR department were interested in whether the 6 questions we started with are a good predictor of this.  \nWe could imagine conducting an analysis like the below:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# add the PCA scores to the dataset\njob <- \n  job %>% mutate(\n    skills_score1 = job_pca2$scores[,1],\n    skills_score2 = job_pca2$scores[,2]\n  )\n# use the scores in an analysis\nlm(nr_arrests ~ skills_score1 + skills_score2, data = job)\n```\n:::\n\n\n:::\n\n\n\n## Plotting the retained principal components\n\nWe can also visualise the statistical units (police officers) in the reduced space given by the retained principal component scores.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntibble(pc1 = job_pca$scores[, 1],\n       pc2 = job_pca$scores[, 2]) %>%\n  ggplot(.,aes(x=pc1,y=pc2))+\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](09_pca_files/figure-html/unnamed-chunk-41-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>",
    "supporting": [
      "09_pca_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/panelset-0.2.6/panelset.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/panelset-0.2.6/panelset.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}